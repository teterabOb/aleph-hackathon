{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts-ccip/src/v0.8/ccip/applications/CCIPReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IAny2EVMMessageReceiver} from \"../interfaces/IAny2EVMMessageReceiver.sol\";\n\nimport {Client} from \"../libraries/Client.sol\";\n\nimport {IERC165} from \"../../vendor/openzeppelin-solidity/v4.8.3/contracts/utils/introspection/IERC165.sol\";\n\n/// @title CCIPReceiver - Base contract for CCIP applications that can receive messages.\nabstract contract CCIPReceiver is IAny2EVMMessageReceiver, IERC165 {\n  address internal immutable i_ccipRouter;\n\n  constructor(address router) {\n    if (router == address(0)) revert InvalidRouter(address(0));\n    i_ccipRouter = router;\n  }\n\n  /// @notice IERC165 supports an interfaceId\n  /// @param interfaceId The interfaceId to check\n  /// @return true if the interfaceId is supported\n  /// @dev Should indicate whether the contract implements IAny2EVMMessageReceiver\n  /// e.g. return interfaceId == type(IAny2EVMMessageReceiver).interfaceId || interfaceId == type(IERC165).interfaceId\n  /// This allows CCIP to check if ccipReceive is available before calling it.\n  /// If this returns false or reverts, only tokens are transferred to the receiver.\n  /// If this returns true, tokens are transferred and ccipReceive is called atomically.\n  /// Additionally, if the receiver address does not have code associated with\n  /// it at the time of execution (EXTCODESIZE returns 0), only tokens will be transferred.\n  function supportsInterface(bytes4 interfaceId) public pure virtual override returns (bool) {\n    return interfaceId == type(IAny2EVMMessageReceiver).interfaceId || interfaceId == type(IERC165).interfaceId;\n  }\n\n  /// @inheritdoc IAny2EVMMessageReceiver\n  function ccipReceive(Client.Any2EVMMessage calldata message) external virtual override onlyRouter {\n    _ccipReceive(message);\n  }\n\n  /// @notice Override this function in your implementation.\n  /// @param message Any2EVMMessage\n  function _ccipReceive(Client.Any2EVMMessage memory message) internal virtual;\n\n  /////////////////////////////////////////////////////////////////////\n  // Plumbing\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Return the current router\n  /// @return CCIP router address\n  function getRouter() public view returns (address) {\n    return address(i_ccipRouter);\n  }\n\n  error InvalidRouter(address router);\n\n  /// @dev only calls from the set router are accepted.\n  modifier onlyRouter() {\n    if (msg.sender != address(i_ccipRouter)) revert InvalidRouter(msg.sender);\n    _;\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IAny2EVMMessageReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Client} from \"../libraries/Client.sol\";\n\n/// @notice Application contracts that intend to receive messages from\n/// the router should implement this interface.\ninterface IAny2EVMMessageReceiver {\n  /// @notice Called by the Router to deliver a message.\n  /// If this reverts, any token transfers also revert. The message\n  /// will move to a FAILED state and become available for manual execution.\n  /// @param message CCIP Message\n  /// @dev Note ensure you check the msg.sender is the OffRampRouter\n  function ccipReceive(Client.Any2EVMMessage calldata message) external;\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Client} from \"../libraries/Client.sol\";\n\ninterface IRouterClient {\n  error UnsupportedDestinationChain(uint64 destChainSelector);\n  error InsufficientFeeTokenAmount();\n  error InvalidMsgValue();\n\n  /// @notice Checks if the given chain ID is supported for sending/receiving.\n  /// @param chainSelector The chain to check.\n  /// @return supported is true if it is supported, false if not.\n  function isChainSupported(uint64 chainSelector) external view returns (bool supported);\n\n  /// @notice Gets a list of all supported tokens which can be sent or received\n  /// to/from a given chain id.\n  /// @param chainSelector The chainSelector.\n  /// @return tokens The addresses of all tokens that are supported.\n  function getSupportedTokens(uint64 chainSelector) external view returns (address[] memory tokens);\n\n  /// @param destinationChainSelector The destination chainSelector\n  /// @param message The cross-chain CCIP message including data and/or tokens\n  /// @return fee returns execution fee for the message\n  /// delivery to destination chain, denominated in the feeToken specified in the message.\n  /// @dev Reverts with appropriate reason upon invalid message.\n  function getFee(\n    uint64 destinationChainSelector,\n    Client.EVM2AnyMessage memory message\n  ) external view returns (uint256 fee);\n\n  /// @notice Request a message to be sent to the destination chain\n  /// @param destinationChainSelector The destination chain ID\n  /// @param message The cross-chain CCIP message including data and/or tokens\n  /// @return messageId The message ID\n  /// @dev Note if msg.value is larger than the required fee (from getFee) we accept\n  /// the overpayment with no refund.\n  /// @dev Reverts with appropriate reason upon invalid message.\n  function ccipSend(\n    uint64 destinationChainSelector,\n    Client.EVM2AnyMessage calldata message\n  ) external payable returns (bytes32);\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// End consumer library.\nlibrary Client {\n  /// @dev RMN depends on this struct, if changing, please notify the RMN maintainers.\n  struct EVMTokenAmount {\n    address token; // token address on the local chain.\n    uint256 amount; // Amount of tokens.\n  }\n\n  struct Any2EVMMessage {\n    bytes32 messageId; // MessageId corresponding to ccipSend on source.\n    uint64 sourceChainSelector; // Source chain selector.\n    bytes sender; // abi.decode(sender) if coming from an EVM chain.\n    bytes data; // payload sent in original message.\n    EVMTokenAmount[] destTokenAmounts; // Tokens and their amounts in their destination chain representation.\n  }\n\n  // If extraArgs is empty bytes, the default is 200k gas limit.\n  struct EVM2AnyMessage {\n    bytes receiver; // abi.encode(receiver address) for dest EVM chains\n    bytes data; // Data payload\n    EVMTokenAmount[] tokenAmounts; // Token transfers\n    address feeToken; // Address of feeToken. address(0) means you will send msg.value.\n    bytes extraArgs; // Populate this with _argsToBytes(EVMExtraArgsV1)\n  }\n\n  // bytes4(keccak256(\"CCIP EVMExtraArgsV1\"));\n  bytes4 public constant EVM_EXTRA_ARGS_V1_TAG = 0x97a657c9;\n  struct EVMExtraArgsV1 {\n    uint256 gasLimit;\n  }\n\n  function _argsToBytes(EVMExtraArgsV1 memory extraArgs) internal pure returns (bytes memory bts) {\n    return abi.encodeWithSelector(EVM_EXTRA_ARGS_V1_TAG, extraArgs);\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n  /**\n   * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n   * given ``owner``'s signed approval.\n   *\n   * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n   * ordering also apply here.\n   *\n   * Emits an {Approval} event.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   * - `deadline` must be a timestamp in the future.\n   * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n   * over the EIP712-formatted function arguments.\n   * - the signature must use ``owner``'s current nonce (see {nonces}).\n   *\n   * For more information on the signature format, see the\n   * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n   * section].\n   */\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  /**\n   * @dev Returns the current nonce for `owner`. This value must be\n   * included whenever a signature is generated for {permit}.\n   *\n   * Every successful call to {permit} increases ``owner``'s nonce by one. This\n   * prevents a signature from being used multiple times.\n   */\n  function nonces(address owner) external view returns (uint256);\n\n  /**\n   * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n   */\n  // solhint-disable-next-line func-name-mixedcase\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `to`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address to, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `from` to `to` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n  using Address for address;\n\n  function safeTransfer(IERC20 token, address to, uint256 value) internal {\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n  }\n\n  function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n  }\n\n  /**\n   * @dev Deprecated. This function has issues similar to the ones found in\n   * {IERC20-approve}, and its usage is discouraged.\n   *\n   * Whenever possible, use {safeIncreaseAllowance} and\n   * {safeDecreaseAllowance} instead.\n   */\n  function safeApprove(IERC20 token, address spender, uint256 value) internal {\n    // safeApprove should only be called when setting an initial allowance,\n    // or when resetting it to zero. To increase and decrease it, use\n    // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n    require(\n      (value == 0) || (token.allowance(address(this), spender) == 0),\n      \"SafeERC20: approve from non-zero to non-zero allowance\"\n    );\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n  }\n\n  function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n    uint256 newAllowance = token.allowance(address(this), spender) + value;\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n  }\n\n  function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n    unchecked {\n      uint256 oldAllowance = token.allowance(address(this), spender);\n      require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n      uint256 newAllowance = oldAllowance - value;\n      _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n  }\n\n  function safePermit(\n    IERC20Permit token,\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) internal {\n    uint256 nonceBefore = token.nonces(owner);\n    token.permit(owner, spender, value, deadline, v, r, s);\n    uint256 nonceAfter = token.nonces(owner);\n    require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n  }\n\n  /**\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n   * on the return value: the return value is optional (but if data is returned, it must not be false).\n   * @param token The token targeted by the call.\n   * @param data The call data (encoded using abi.encode or one of its variants).\n   */\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n    // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n    // the target address contains contract code and also asserts for success in the low-level call.\n\n    bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n    if (returndata.length > 0) {\n      // Return data is optional\n      require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n  /**\n   * @dev Returns true if `account` is a contract.\n   *\n   * [IMPORTANT]\n   * ====\n   * It is unsafe to assume that an address for which this function returns\n   * false is an externally-owned account (EOA) and not a contract.\n   *\n   * Among others, `isContract` will return false for the following\n   * types of addresses:\n   *\n   *  - an externally-owned account\n   *  - a contract in construction\n   *  - an address where a contract will be created\n   *  - an address where a contract lived, but was destroyed\n   * ====\n   *\n   * [IMPORTANT]\n   * ====\n   * You shouldn't rely on `isContract` to protect against flash loan attacks!\n   *\n   * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n   * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n   * constructor.\n   * ====\n   */\n  function isContract(address account) internal view returns (bool) {\n    // This method relies on extcodesize/address.code.length, which returns 0\n    // for contracts in construction, since the code is only stored at the end\n    // of the constructor execution.\n\n    return account.code.length > 0;\n  }\n\n  /**\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n   * `recipient`, forwarding all available gas and reverting on errors.\n   *\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\n   * imposed by `transfer`, making them unable to receive funds via\n   * `transfer`. {sendValue} removes this limitation.\n   *\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n   *\n   * IMPORTANT: because control is transferred to `recipient`, care must be\n   * taken to not create reentrancy vulnerabilities. Consider using\n   * {ReentrancyGuard} or the\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n   */\n  function sendValue(address payable recipient, uint256 amount) internal {\n    require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n    (bool success, ) = recipient.call{value: amount}(\"\");\n    require(success, \"Address: unable to send value, recipient may have reverted\");\n  }\n\n  /**\n   * @dev Performs a Solidity function call using a low level `call`. A\n   * plain `call` is an unsafe replacement for a function call: use this\n   * function instead.\n   *\n   * If `target` reverts with a revert reason, it is bubbled up by this\n   * function (like regular Solidity function calls).\n   *\n   * Returns the raw returned data. To convert to the expected return value,\n   * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n   *\n   * Requirements:\n   *\n   * - `target` must be a contract.\n   * - calling `target` with `data` must not revert.\n   *\n   * _Available since v3.1._\n   */\n  function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n   * `errorMessage` as a fallback revert reason when `target` reverts.\n   *\n   * _Available since v3.1._\n   */\n  function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, 0, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but also transferring `value` wei to `target`.\n   *\n   * Requirements:\n   *\n   * - the calling contract must have an ETH balance of at least `value`.\n   * - the called Solidity function must be `payable`.\n   *\n   * _Available since v3.1._\n   */\n  function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n   * with `errorMessage` as a fallback revert reason when `target` reverts.\n   *\n   * _Available since v3.1._\n   */\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    require(address(this).balance >= value, \"Address: insufficient balance for call\");\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but performing a static call.\n   *\n   * _Available since v3.3._\n   */\n  function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n    return functionStaticCall(target, data, \"Address: low-level static call failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n   * but performing a static call.\n   *\n   * _Available since v3.3._\n   */\n  function functionStaticCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal view returns (bytes memory) {\n    (bool success, bytes memory returndata) = target.staticcall(data);\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but performing a delegate call.\n   *\n   * _Available since v3.4._\n   */\n  function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n    return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n   * but performing a delegate call.\n   *\n   * _Available since v3.4._\n   */\n  function functionDelegateCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    (bool success, bytes memory returndata) = target.delegatecall(data);\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n   * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n   *\n   * _Available since v4.8._\n   */\n  function verifyCallResultFromTarget(\n    address target,\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n  ) internal view returns (bytes memory) {\n    if (success) {\n      if (returndata.length == 0) {\n        // only check isContract if the call was successful and the return data is empty\n        // otherwise we already know that it was a contract\n        require(isContract(target), \"Address: call to non-contract\");\n      }\n      return returndata;\n    } else {\n      _revert(returndata, errorMessage);\n    }\n  }\n\n  /**\n   * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n   * revert reason or using the provided one.\n   *\n   * _Available since v4.3._\n   */\n  function verifyCallResult(\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n  ) internal pure returns (bytes memory) {\n    if (success) {\n      return returndata;\n    } else {\n      _revert(returndata, errorMessage);\n    }\n  }\n\n  function _revert(bytes memory returndata, string memory errorMessage) private pure {\n    // Look for revert reason and bubble it up if present\n    if (returndata.length > 0) {\n      // The easiest way to bubble the revert reason is using memory via assembly\n      /// @solidity memory-safe-assembly\n      assembly {\n        let returndata_size := mload(returndata)\n        revert(add(32, returndata), returndata_size)\n      }\n    } else {\n      revert(errorMessage);\n    }\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "contracts/ArbitrumReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport { CCIPReceiver } from \"@chainlink/contracts-ccip/src/v0.8/ccip/applications/CCIPReceiver.sol\";\nimport { Client } from \"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol\";\nimport { IERC20 } from \"@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/IERC20.sol\";\n\ncontract ArbitrumReceiver is CCIPReceiver{\n    address public _usdcToken = 0x75faf114eafb1BDbe2F0316DF893fd58CE46AA4d;\n\n    struct Messages { \n        uint256 id;\n        address businessAddress;\n        uint256 businessAmount;\n        address dispatcherAddress;\n        uint256 dispatcherAmount;\n    }\n\n    mapping(uint256 => Messages) public messages;\n    mapping(address => uint256) public balances;\n\n\tconstructor(address router) CCIPReceiver(router){}\n\n\tfunction _ccipReceive(\n\t\tClient.Any2EVMMessage memory message\n\t) internal override {\n\t\t(uint256 id, address businessAddress, uint256 businessAmount, address dispatcherAddress, uint256 dispatcherAmount) = \n        abi.decode(message.data, (uint256,address,uint256,address,uint256));\n\t\tmessages[id] = Messages(id, businessAddress, businessAmount, dispatcherAddress, dispatcherAmount);\n        balances[dispatcherAddress] += dispatcherAmount;\n        balances[businessAddress] -= businessAmount;\n\t}\n\n    function withdraw() public {\n        uint256 amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n        IERC20(_usdcToken).transfer(msg.sender, amount);\n    }\n}\n"
    },
    "contracts/CCIPSender.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport { IRouterClient } from \"@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol\";\nimport { Client } from \"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol\";\nimport { IERC20 } from \"@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ncontract CCIPSender {\n    /**\n    AVAX Fuji\n    Router: 0xF694E193200268f9a4868e4Aa017A0118C9a8177\n    ChainSelector: 14767482510784806043\n    LINK Address: 0x0b9d5D9136855f6FEc3c0993feE6E9CE8a297846\n    USDC: \n    */\n    /**\n    Arbitrum Sepolia\n    Router: 0x2a9C5afB0d0e4BAb2BCdaE109EC4b0c4Be15a165\n    ChainSelector: 3478487238524512106\n    LINK Address: \n     */\n\tusing SafeERC20 for IERC20;\n\n\tstruct CCIPConfig {\n\t\taddress router;\n\t\taddress chainId;\n\t}\n\n\tstruct Messages {\n\t\tuint256 id;\n\t\taddress receiver;\n\t\tuint256 amount;\n\t}\n\n\taddress public receiverCCIPArbitrum;\n    // Info hardcoded for AVAX Fuji\n\tIERC20 private immutable _linkToken = IERC20(0x0b9d5D9136855f6FEc3c0993feE6E9CE8a297846);\n    IERC20 private immutable _usdcToken = IERC20(0x5425890298aed601595a70AB815c96711a31Bc65);\n\tIRouterClient public router = IRouterClient(0xF694E193200268f9a4868e4Aa017A0118C9a8177);\n\tuint64 public destinationChainSelector = 3478487238524512106;  // Arbitrum Sepolia\n    address public owner;\n    address public receiverTeleporter;\n\n\tmapping(uint256 => bool) public sentMessages;\n\n\tevent TransferUSDCCIP(uint256 indexed id, address businessAddress, uint256 indexed businessAmount, address dispatcherAddress, uint256 indexed dispatcherAmount);\n    event EncodeedData(bytes data);\n\tevent TeleporterSender(address teleporterSender);\n\n    error InvalidUsdcToken();\n\terror NotEnoughBalanceForFees(uint256 balance, uint256 fees);\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function transferUSDCCIP(\n\t\tuint256 id,\n\t\taddress businessAddress,\n\t\tuint256 businessAmount,\n\t\taddress dispatcherAddress,\n\t\tuint256 dispatcherAmount\n\t) external {\n\t\trequire(receiverCCIPArbitrum != address(0), \"CCIPSender: receiver not set\");\n\t\trequire(!sentMessages[id], \"CCIPSender: message already sent\");\t\t\n\t\tsentMessages[id] = true;\n\t\tbytes memory message = abi.encode(\"(uint256,address,uint256,address,uint256)\", \n\t\tid, businessAddress, businessAmount, dispatcherAddress, dispatcherAmount);\n\t\tuint256 finalAmount = businessAmount + dispatcherAmount;\n\t\t_sendCrossChainMessage(finalAmount, message);\n\t\temit TeleporterSender(msg.sender);\n\t\temit TransferUSDCCIP(id, businessAddress, businessAmount, dispatcherAddress, dispatcherAmount);\n\t}\n\n\tfunction _sendCrossChainMessage(\n\t\tuint256 amount,\n\t\tbytes memory data\n\t) internal returns (bytes32 messageId) {\n\t\tClient.EVM2AnyMessage memory message = _buildCCIPMessage(\n\t\t\treceiverCCIPArbitrum, // receiver ccip contract\n\t\t\taddress(_usdcToken), // token USDC\n\t\t\tamount, // amount\n\t\t\taddress(_linkToken), // LINK Token\n\t\t\tdata\n\t\t);\n\n\t\tuint256 fees = router.getFee(destinationChainSelector, message);\n\t\tif (fees > _linkToken.balanceOf(address(this))) {\n\t\t\trevert NotEnoughBalanceForFees(_linkToken.balanceOf(address(this)), fees);\n\t\t}\n\n\t\tmessageId = router.ccipSend(destinationChainSelector, message);\n        return messageId;\n\t}\n\n    function infinitApproveLink() onlyOwner public {\n        _linkToken.approve(address(router), type(uint256).max);\n    }\n\n    function infinitApproveUSDC() onlyOwner public {\n        _usdcToken.approve(address(router), type(uint256).max);\n    }\n\n    function withdrawLink() public onlyOwner {\n        _linkToken.safeTransfer(owner, _linkToken.balanceOf(address(this)));\n    }\n\n    function withdrawUSDC() public onlyOwner {\n        _usdcToken.safeTransfer(owner, _usdcToken.balanceOf(address(this)));\n    }\n\n\tfunction updateArbitrumCCIPReceiver(address newReceiver) public onlyOwner {\n\t\trequire(newReceiver != address(0), \"CCIPSender: invalid receiver address\");\n\t\treceiverCCIPArbitrum = newReceiver;\n\t}\n\n\tfunction _buildCCIPMessage(\n\t\taddress receiver,\n\t\taddress token,\n\t\tuint256 amount,\n\t\taddress feeTokenAddress,\n\t\tbytes memory data\n\t) internal pure returns (Client.EVM2AnyMessage memory) {\n\t\tClient.EVMTokenAmount[]\n\t\t\tmemory tokenAmounts = new Client.EVMTokenAmount[](1);\n\n\t\ttokenAmounts[0] = Client.EVMTokenAmount({\n\t\t\ttoken: token,\n\t\t\tamount: amount\n\t\t});\n\n\t\treturn\n\t\t\tClient.EVM2AnyMessage({\n\t\t\t\treceiver: abi.encode(receiver),\n\t\t\t\tdata: data,\n\t\t\t\ttokenAmounts: tokenAmounts,\n\t\t\t\textraArgs: Client._argsToBytes(\n\t\t\t\t\tClient.EVMExtraArgsV1({ gasLimit: 200_000 })\n\t\t\t\t),\n\t\t\t\tfeeToken: feeTokenAddress\n\t\t\t});\n\t}\n\n    modifier onlyReceiverTeleporter(){\n        require(msg.sender == receiverTeleporter, \"CCIPSender: unauthorized TeleporterMessenger\");\n        _;\n    }\n\n    modifier onlyOwner(){\n        require(msg.sender == owner, \"CCIPSender: unauthorized Owner\");\n        _;\n    }\n}\n"
    },
    "contracts/DispatchCChain.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\nimport \"../lib/contracts/teleporter/ITeleporterMessenger.sol\";\nimport \"../lib/contracts/teleporter/ITeleporterReceiver.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {CCIPSender} from \"./CCIPSender.sol\";\nimport {DispatchEcho} from \"./DispatchEcho.sol\";\n\n// This contract will be deployed on AVALANCHE\ncontract DispatchCChain is ITeleporterReceiver {\n\tuint256 public immutable feePercentage = 15;\n\tuint256 public totalTransfered;\n\tuint256 public idCounter;\n\taddress public owner;\n    address public ccipSender;\n\tbytes public lastMessage;\n\taddress public dispatchEcoContrat;\n\tIERC20 private immutable _usdcToken = IERC20(0x5425890298aed601595a70AB815c96711a31Bc65);\n\tITeleporterMessenger public immutable messenger = ITeleporterMessenger(0x253b2784c75e510dD0fF1da844684a1aC0aa5fcf);\n\n\tstruct DispatchStruct {\n\t\tuint256 id;\n\t\taddress clientAddress;\n\t\tuint256 totalAmount;\n\t\taddress dispatcherAddress;\n\t\tuint256 dispatcherAmount;\n\t\taddress businessAddress;\n\t\tuint256 businessAmount;\n\t}\n\n\tconstructor() {\n\t\towner = msg.sender;\n\t}\n\n\tmapping(uint256 => DispatchStruct) public dispatches;\n\tmapping(uint256 => bool) public dispatched;\n\n\tevent Deposited(\n\t\tuint256 indexed id,\n\t\taddress indexed clientAddress,\n\t\taddress indexed businessAddress,\n\t\tuint256 amount\n\t);\n\tevent ReceivedMessage(bytes message);\n\n\n\n\tfunction getDispatchStruct(\n\t\tuint256 id,\n\t\t/* totalAmount */\n\t\t/* dispatcherAddress  */\n\t\t/* dispatcherAmount */\n\t\taddress businessAddress,\n\t\tuint256 amount /* + Fee = businessAmount */\n\t) public view returns (DispatchStruct memory) {\n\t\tuint256 fee = _calculateFee(amount);\n\t\tuint256 totalAmount = amount + fee;\n\n\t\tDispatchStruct memory dispatchStruct = DispatchStruct({\n\t\t\tid: id,\n\t\t\tclientAddress: msg.sender,\n\t\t\ttotalAmount: totalAmount,\n\t\t\tdispatcherAddress: address(0),\n\t\t\tdispatcherAmount: fee,\n\t\t\tbusinessAddress: businessAddress,\n\t\t\tbusinessAmount: amount\n\t\t});\n\n\t\treturn dispatchStruct;\n\t}\n\n\tfunction sendMessage(\n\t\t\taddress destinationAddress, \n\t\t\tuint256 id, \n\t\t\taddress clientAddress,\n\t\t\tuint256 totalAmount,\n\t\t\taddress dispatcherAddress,\n\t\t\tuint256 dispatcherAmount,\n\t\t\taddress businessAddress,\n\t\t\tuint256 businessAmount,\n\t\t\tuint256 gasLimit\n\t) public {\n        bytes memory encodedFunctionCall = \n        abi.encodeWithSignature(\"placeDispatch(uint256,address,uint256,address,uint256,address,uint256)\", \n\t\tid, clientAddress, totalAmount,dispatcherAddress, dispatcherAmount, businessAddress, businessAmount);\n    \n        messenger.sendCrossChainMessage(\n            TeleporterMessageInput({\n                destinationBlockchainID: 0x9f3be606497285d0ffbb5ac9ba24aa60346a9b1812479ed66cb329f394a4b1c7,\n                destinationAddress: destinationAddress,\n                feeInfo: TeleporterFeeInfo({feeTokenAddress: address(0), amount: 0}),\n                requiredGasLimit: gasLimit,\n                allowedRelayerAddresses: new address[](0),\n                message: encodedFunctionCall\n            })\n        );\n    }\n\n\tfunction _sendMessageMockUp(\n\t\t\taddress destinationAddress, \n\t\t\tuint256 id, \n\t\t\taddress clientAddress,\n\t\t\tuint256 totalAmount,\n\t\t\taddress dispatcherAddress,\n\t\t\tuint256 dispatcherAmount,\n\t\t\taddress businessAddress,\n\t\t\tuint256 businessAmount,\n\t\t\tuint256 gasLimit\n\t) internal {\n        bytes memory encodedFunctionCall = \n        abi.encodeWithSignature(\"placeDispatch(uint256,address,uint256,address,uint256,address,uint256)\", \n\t\tid, clientAddress, totalAmount,dispatcherAddress, dispatcherAmount, businessAddress, businessAmount);\n\t\tDispatchEcho(dispatchEcoContrat).receiveTeleporterMessageMockUp(\n\t\t\tencodedFunctionCall\n\t\t);\n\t}\n\t\t\n    // @param businessAddress The address of the business\n\t// @param destinationAddress The address of the contract on the destination chain\n    // @dev first function that has to be called\n\tfunction payout(address businessAddress, uint256 amount, address destinationAddress, uint256 gasLimit) public {\n        require(ccipSender != address(0), \"ReceiverOnSubnet: CCIPSender not set\");\n\t\tidCounter++;\n\t\tDispatchStruct memory dispatchStruct = getDispatchStruct(\n\t\t\tidCounter,\n\t\t\tbusinessAddress,\n\t\t\tamount\n\t\t);\n\n\t\t\n\t\trequire(\n\t\t\t_usdcToken.balanceOf(msg.sender) > dispatchStruct.totalAmount,\n\t\t\t\"Dispatch CChain: Insufficient USDC\"\n\t\t);\n\t\t\n\t\t// Remember to execute approve before calling this function\n\t\t_usdcToken.transferFrom(\n\t\t\tmsg.sender,\n\t\t\tccipSender, // CCIPSender will handle Cross-Chain Transfer\n\t\t\tdispatchStruct.totalAmount\n\t\t);\n\n\t\tdispatched[idCounter] = false;\n\t\tdispatches[idCounter] = dispatchStruct;\n\t\temit Deposited(idCounter, msg.sender, businessAddress, amount);\n\n\t\t// Send message to Dispatcher\n\t\t// We are using the mockup function to simulate the message\n\t\t// because teleporter is out of funds cuz of us\n\t\t_sendMessageMockUp(\n\t\t\tdestinationAddress,\n\t\t\tidCounter,\n\t\t\tmsg.sender,\n\t\t\tdispatchStruct.totalAmount,\n\t\t\taddress(0),\n\t\t\tdispatchStruct.dispatcherAmount,\n\t\t\tbusinessAddress,\n\t\t\tamount,\n\t\t\tgasLimit\n\t\t);\n\t}\n\n\tfunction receiveTeleporterMessage(\n\t\tbytes32,\n\t\taddress,\n\t\tbytes calldata message\n\t) external {\n\t\t(uint256 id, address dispatcherAddress) = abi\n\t\t\t.decode(message[4:], (uint256, address));\n\t\tcompleteOrder(id, dispatcherAddress);\n\t\temit ReceivedMessage(message);\n\t}\n\n\tfunction receiveTeleporterMessageMockUp(\n\t\tbytes calldata message\n\t) external {\n\t\t(uint256 id, address dispatcherAddress) = abi\n\t\t\t.decode(message[4:], (uint256, address));\n\t\tcompleteOrder(id, dispatcherAddress);\n\t\temit ReceivedMessage(message);\n\t}\n\n\t// @param id The id of the dispatch\n\tfunction completeOrder(uint256 id, address dispatcherAddress) public {\n\t\tDispatchStruct storage ds = dispatches[id];\n\t\tds.dispatcherAddress = dispatcherAddress;\n\t\trequire(!dispatched[id], \"Dispatch: already dispatched\");\t\t\n\t\tdispatched[id] = true;\n\t\ttotalTransfered += ds.businessAmount;\n\t\tCCIPSender(ccipSender).transferUSDCCIP(id, ds.businessAddress, ds.businessAmount, ds.dispatcherAddress, ds.dispatcherAmount);\n\t}\n\n\tfunction _calculateFee(uint256 amount) internal view returns (uint256) {\n\t\treturn (amount * feePercentage) / 100;\n\t}\n\n\tfunction emergencyWithdrawUSDC() public onlyOwner {\n\t\t_usdcToken.transfer(msg.sender, _usdcToken.balanceOf(address(this)));\n\t}\n\n\tfunction approveInfinite() public {\n\t\t_usdcToken.approve(address(this), type(uint256).max);\n\t}\n\n    function updateCCIPSender(address newCCIPSender) external onlyOwner() {\n        require(newCCIPSender != address(0), \"ReceiverOnSubnet: invalid CCIPSender address\");\n        ccipSender = newCCIPSender;\n    }\n\n\tfunction updateDispatchEchoContract(address newDispatchEchoContract) external onlyOwner() {\n\t\trequire(newDispatchEchoContract != address(0), \"ReceiverOnSubnet: invalid DispatchEcho address\");\n\t\tdispatchEcoContrat = newDispatchEchoContract;\n\t}\n\n\tmodifier onlyOwner() {\n\t\trequire(msg.sender == owner, \"ReceiverOnSubnet: only owner\");\n\t\t_;\n\t}\n}\n\n"
    },
    "contracts/DispatchEcho.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../lib/contracts/teleporter/ITeleporterMessenger.sol\";\nimport \"../lib/contracts/teleporter/ITeleporterReceiver.sol\";\nimport {DispatchCChain} from \"./DispatchCChain.sol\";\n\ncontract DispatchEcho is ITeleporterReceiver {\n    ITeleporterMessenger public immutable messenger = ITeleporterMessenger(0x253b2784c75e510dD0fF1da844684a1aC0aa5fcf);\n    address public dispatchContract;\n    address public owner;\n\n    enum DispatchStatus {\n        Placed,\n        Transit,\n        Completed,\n        Failed\n    }\n\n    struct DispatchStruct {\n\t\tuint256 id;\n\t\taddress clientAddress;\n\t\tuint256 totalAmount;\n\t\taddress dispatcherAddress;\n\t\tuint256 dispatcherAmount;\n\t\taddress businessAddress;\n\t\tuint256 businessAmount;\n\t}\n\n    mapping(uint256 => bool) public dispatchAssigned;\n    mapping(uint256 => DispatchStruct) public dispatches;\n    mapping(uint256 => DispatchStatus) public dispatchStatus;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    event ReceivedMessage(bytes message);\n    event OrderTaken(uint256 id, address dispatcherAddress);\n\n    /**\n     * @dev Sends a message to another chain.\n     */\n    function sendMessage(address destinationAddress, uint256 id, address dispatcherAddress, uint256 amount, uint256 gasLimit) external {\n        bytes memory encodedFunctionCall = \n        abi.encodeWithSignature(\"finalize(uint256,address)\", id, dispatcherAddress);\n    \n        messenger.sendCrossChainMessage(\n            TeleporterMessageInput({\n                destinationBlockchainID: 0x7fc93d85c6d62c5b2ac0b519c87010ea5294012d1e407030d6acd0021cac10d5,\n                destinationAddress: destinationAddress,\n                feeInfo: TeleporterFeeInfo({feeTokenAddress: address(0), amount: 0}),\n                requiredGasLimit: gasLimit,\n                allowedRelayerAddresses: new address[](0),\n                message: encodedFunctionCall\n            })\n        );\n    }\n\n    function sendMessageMockUp(address destinationAddress, uint256 id, address dispatcherAddress, uint256 amount, uint256 gasLimit) external {\n        bytes memory encodedFunctionCall = \n        abi.encodeWithSignature(\"completeOrder(uint256,address)\", id, dispatcherAddress);\n        dispatchStatus[id] = DispatchStatus.Completed;\n        DispatchEcho(dispatchContract).receiveTeleporterMessageMockUp(\n            encodedFunctionCall\n        );\n\n    }\n\n    function inputsToMessage(uint256 id, address dispatcherAddress) external pure returns (bytes memory) {\n        return \n        abi.encodeWithSignature(\"completeOrder(uint256,address)\", id, dispatcherAddress);\n    }\n\n    //Change to internal\n    function placeDispatch(\n            uint256 id, \n            address clientAddress, \n            uint256 totalAmount, \n            address dispatcherAddress, \n            uint256 dispatcherAmount, \n            address businessAddress, \n            uint256 businessAmount\n        ) public {\n        require(!dispatchAssigned[id], \"Dispatch already assigned\");\n        dispatches[id] = DispatchStruct(id, clientAddress, totalAmount, dispatcherAddress, dispatcherAmount, businessAddress, businessAmount);\n    }\n\n    // Dispatch take Order\n    function takeOrder(uint256 id) external {\n        DispatchStruct storage dispatch = dispatches[id];\n        dispatch.dispatcherAddress = msg.sender;\n        dispatchAssigned[id] = true;\n        dispatchStatus[id] = DispatchStatus.Transit;\n        emit OrderTaken(id, msg.sender);\n    }\n\n    // Function for production\n    function receiveTeleporterMessage(bytes32, address, bytes calldata message) external {\n        // Only the Teleporter receiver can deliver a message.\n        require(msg.sender == address(messenger), \"ReceiverOnSubnet: unauthorized TeleporterMessenger\");\n        (uint256 id, address clientAddress, uint256 totalAmount, address dispatcherAddress, uint256 dispatcherAmount, address businessAddress, uint256 businessAmount) = \n        abi.decode(message[4:], (uint256,address,uint256,address,uint256,address,uint256));\n        placeDispatch(id, clientAddress, totalAmount, dispatcherAddress, dispatcherAmount, businessAddress, businessAmount);\n        emit ReceivedMessage(message);\n    }\n\n    // Function for testing\n    function receiveTeleporterMessageMockUp(bytes calldata message) external {\n        (uint256 id, address clientAddress, uint256 totalAmount, address dispatcherAddress, uint256 dispatcherAmount, address businessAddress, uint256 businessAmount) = \n        abi.decode(message[4:], (uint256,address,uint256,address,uint256,address,uint256));\n        placeDispatch(id, clientAddress, totalAmount, dispatcherAddress, dispatcherAmount, businessAddress, businessAmount);\n        emit ReceivedMessage(message);\n    }\n\n    function updateDispatchContract(address newDispatchContract) external {\n        dispatchContract = newDispatchContract;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only the dispatch contract can call this function\");\n        _;\n    }\n}\n\n"
    },
    "lib/contracts/teleporter/ITeleporterMessenger.sol": {
      "content": "// (c) 2023, Ava Labs, Inc. All rights reserved.\n// See the file LICENSE for licensing terms.\n\n// SPDX-License-Identifier: Ecosystem\n\npragma solidity 0.8.25;\n\n// A message receipt identifies the message that was delivered by its nonce,\n// and the address that can redeem the reward for that message.\nstruct TeleporterMessageReceipt {\n    uint256 receivedMessageNonce;\n    address relayerRewardAddress;\n}\n\n// Represents all of the information required for submitting a Teleporter message\n// to be sent to the given destination chain ID and address. Includes the fee\n// information for the message, the amount of gas the relayer must provide to execute\n// the message on the destination chain, the relayer accounts allowed to deliver the\n// message, and the message data itself.\nstruct TeleporterMessageInput {\n    bytes32 destinationBlockchainID;\n    address destinationAddress;\n    TeleporterFeeInfo feeInfo;\n    uint256 requiredGasLimit;\n    address[] allowedRelayerAddresses;\n    bytes message;\n}\n\n// Represents a message sent or received by an implementation of {ITeleporterMessenger}.\nstruct TeleporterMessage {\n    uint256 messageNonce;\n    address originSenderAddress;\n    bytes32 destinationBlockchainID;\n    address destinationAddress;\n    uint256 requiredGasLimit;\n    address[] allowedRelayerAddresses;\n    TeleporterMessageReceipt[] receipts;\n    bytes message;\n}\n\n// Represents the fee information associated to a given Teleporter message.\n// The contract address is the asset contract the fee will be paid in, and\n// the amount is the amount of that specified asset.\nstruct TeleporterFeeInfo {\n    address feeTokenAddress;\n    uint256 amount;\n}\n\n/**\n * @dev Interface that describes functionalities for a cross-chain messenger implementing the Teleporter protcol.\n *\n * @custom:security-contact https://github.com/ava-labs/teleporter/blob/main/SECURITY.md\n */\ninterface ITeleporterMessenger {\n    /**\n     * @notice Emitted when the blockchain ID of the contract instance is initialized using the Warp precompile.\n     */\n    event BlockchainIDInitialized(bytes32 indexed blockchainID);\n\n    /**\n     * @notice Emitted when sending a Teleporter message cross-chain.\n     */\n    event SendCrossChainMessage(\n        bytes32 indexed messageID,\n        bytes32 indexed destinationBlockchainID,\n        TeleporterMessage message,\n        TeleporterFeeInfo feeInfo\n    );\n\n    /**\n     * @notice Emitted when an additional fee amount is added to a Teleporter message that had previously\n     * been sent, but not yet delivered to the destination chain.\n     */\n    event AddFeeAmount(bytes32 indexed messageID, TeleporterFeeInfo updatedFeeInfo);\n\n    /**\n     * @notice Emitted when a Teleporter message is being delivered on the destination chain to an address,\n     * but message execution fails. Failed messages can then be retried with `retryMessageExecution`\n     */\n    event MessageExecutionFailed(\n        bytes32 indexed messageID, bytes32 indexed sourceBlockchainID, TeleporterMessage message\n    );\n\n    /**\n     * @notice Emitted when a Teleporter message is successfully executed with the\n     * specified destination address and message call data. This can occur either when\n     * the message is initially received, or on a retry attempt.\n     *\n     * Each message received can be executed successfully at most once.\n     */\n    event MessageExecuted(bytes32 indexed messageID, bytes32 indexed sourceBlockchainID);\n\n    /**\n     * @notice Emitted when a TeleporterMessage is successfully received.\n     */\n    event ReceiveCrossChainMessage(\n        bytes32 indexed messageID,\n        bytes32 indexed sourceBlockchainID,\n        address indexed deliverer,\n        address rewardRedeemer,\n        TeleporterMessage message\n    );\n\n    /**\n     * @notice Emitted when a receipt is marked as received on the source chain that sent the\n     * corresponding Teleporter message.\n     */\n    event ReceiptReceived(\n        bytes32 indexed messageID,\n        bytes32 indexed destinationBlockchainID,\n        address indexed relayerRewardAddress,\n        TeleporterFeeInfo feeInfo\n    );\n\n    /**\n     * @notice Emitted when an account redeems accumulated relayer rewards.\n     */\n    event RelayerRewardsRedeemed(address indexed redeemer, address indexed asset, uint256 amount);\n\n    /**\n     * @notice Called by transactions to initiate the sending of a cross-chain message.\n     * @return The message ID of the newly sent message.\n     */\n    function sendCrossChainMessage(TeleporterMessageInput calldata messageInput)\n        external\n        returns (bytes32);\n\n    /**\n     * @notice Called by transactions to retry the sending of a cross-chain message.\n     *\n     * @dev Retriggers the sending of a message previously emitted by sendCrossChainMessage that has not yet been acknowledged\n     * with a receipt from the destination chain. This may be necessary in the unlikely event that less than the required\n     * threshold of stake weight successfully inserted the message in their messages DB at the time of the first submission.\n     * The message is checked to have already been previously submitted by comparing its message hash against those kept in\n     * state until a receipt is received for the message.\n     */\n    function retrySendCrossChainMessage(TeleporterMessage calldata message) external;\n\n    /**\n     * @notice Adds the additional fee amount to the amount to be paid to the relayer that delivers\n     * the given message ID to the destination chain.\n     *\n     * @dev The fee token address must be the same asset type as the fee asset specified in the original\n     * call to sendCrossChainMessage. Reverts if the message doesn't exist or there is already\n     * receipt of delivery of the message.\n     */\n    function addFeeAmount(\n        bytes32 messageID,\n        address feeTokenAddress,\n        uint256 additionalFeeAmount\n    ) external;\n\n    /**\n     * @notice Receives a cross-chain message, and marks the `relayerRewardAddress` for fee reward for a successful delivery.\n     *\n     * @dev The message specified by `messageIndex` must be provided at that index in the access list storage slots of the transaction,\n     * and is verified in the precompile predicate.\n     */\n    function receiveCrossChainMessage(uint32 messageIndex, address relayerRewardAddress) external;\n\n    /**\n     * @notice Retries the execution of a previously delivered message by verifying the payload matches\n     * the hash of the payload originally delivered, and calling the destination address again.\n     *\n     * @dev Intended to be used if message excution failed on initial delivery of the Teleporter message.\n     * For example, this may occur if the original required gas limit was not sufficient for the message\n     * execution, or if the destination address did not contain a contract, but a compatible contract\n     * was later deployed to that address. Messages are ensured to be successfully executed at most once.\n     */\n    function retryMessageExecution(\n        bytes32 sourceBlockchainID,\n        TeleporterMessage calldata message\n    ) external;\n\n    /**\n     * @notice Sends the receipts for the given `messageIDs`.\n     *\n     * @dev Sends the specified message receipts in a new message (with an empty payload) back to the source chain.\n     * This is intended for use in sending receipts that have not been sent in a timely manner by the standard\n     * receipt delivery mechanism.\n     * @return The message ID of the newly sent message.\n     */\n    function sendSpecifiedReceipts(\n        bytes32 sourceBlockchainID,\n        bytes32[] calldata messageIDs,\n        TeleporterFeeInfo calldata feeInfo,\n        address[] calldata allowedRelayerAddresses\n    ) external returns (bytes32);\n\n    /**\n     * @notice Sends any fee amount rewards for the given fee asset out to the caller.\n     */\n    function redeemRelayerRewards(address feeTokenAddress) external;\n\n    /**\n     * @notice Gets the hash of a given message stored in the EVM state, if the message exists.\n     * @return The message hash\n     */\n    function getMessageHash(bytes32 messageID) external view returns (bytes32);\n\n    /**\n     * @notice Checks whether or not the given message has been received by this chain.\n     * @return Boolean representing if the given message has been received.\n     */\n    function messageReceived(bytes32 messageID) external view returns (bool);\n\n    /**\n     * @notice Returns the address the relayer reward should be sent to on the source chain\n     * for a given message, assuming that the message has already been delivered.\n     * @return The relayer reward address for the given message.\n     */\n    function getRelayerRewardAddress(bytes32 messageID) external view returns (address);\n\n    /**\n     * @notice Gets the current reward amount of a given fee asset that is redeemable by the given relayer.\n     * @return The amount of the fee asset redeemable by the specified relayer.\n     */\n    function checkRelayerRewardAmount(\n        address relayer,\n        address feeTokenAddress\n    ) external view returns (uint256);\n\n    /**\n     * @notice Gets the fee token address and amount for a given sent message.\n     * @return The fee token address and fee amount for a the given sent message ID.\n     * If the message ID is not found, zero address and amount values are returned.\n     */\n    function getFeeInfo(bytes32 messageID) external view returns (address, uint256);\n\n    /**\n     * @notice Gets the message ID that would currently be used for the next message sent from the contract\n     * instance to the given destination blockchain.\n     *\n     * @dev This message ID may never be used in the event that the next call to sendCrossChainMessage in a\n     * transaction uses a different destination blockchain. The current value as returned by this function will\n     * change with each successful call to sendCrossChainMessage.\n     * @return The specified message ID.\n     */\n    function getNextMessageID(bytes32 destinationBlockchainID) external view returns (bytes32);\n\n    /**\n     * @notice Gets the number of receipts that are waiting to be sent to the given source chain ID.\n     * @return Size of the given queue.\n     */\n    function getReceiptQueueSize(bytes32 sourceBlockchainID) external view returns (uint256);\n\n    /**\n     * @notice Gets the receipt at the given index in the queue for the given source chain ID.\n     * @return The receipt requested.\n     */\n    function getReceiptAtIndex(\n        bytes32 sourceBlockchainID,\n        uint256 index\n    ) external view returns (TeleporterMessageReceipt memory);\n}\n"
    },
    "lib/contracts/teleporter/ITeleporterReceiver.sol": {
      "content": "// (c) 2022-2023, Ava Labs, Inc. All rights reserved.\n// See the file LICENSE for licensing terms.\n\n// SPDX-License-Identifier: Ecosystem\n\npragma solidity 0.8.25;\n\n/**\n * @dev Interface that cross-chain applications must implement to receive messages from Teleporter.\n *\n * @custom:security-contact https://github.com/ava-labs/teleporter/blob/main/SECURITY.md\n */\ninterface ITeleporterReceiver {\n    /**\n     * @dev Called by TeleporterMessenger on the receiving chain.\n     *\n     * @param sourceBlockchainID is provided by the TeleporterMessenger contract.\n     * @param originSenderAddress is provided by the TeleporterMessenger contract.\n     * @param message is the TeleporterMessage payload set by the sender.\n     */\n    function receiveTeleporterMessage(\n        bytes32 sourceBlockchainID,\n        address originSenderAddress,\n        bytes calldata message\n    ) external;\n}\n"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}