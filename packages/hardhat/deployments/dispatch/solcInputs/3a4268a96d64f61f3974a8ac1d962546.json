{
  "language": "Solidity",
  "sources": {
    "contracts/SenderSubnet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../lib/contracts/teleporter/ITeleporterMessenger.sol\";\n\ncontract SenderSubnet {\n    // Address of Teleporter Messenger contract is the same for all chains\n    ITeleporterMessenger public immutable messenger = ITeleporterMessenger(0x253b2784c75e510dD0fF1da844684a1aC0aa5fcf);\n\n    /**\n     * @dev Sends a message to another chain.\n     */\n    function sendMessage(address destinationAddress, uint256 id, address receiver, uint256 amount) external {\n        bytes memory encodedFunctionCall = \n        abi.encodeWithSignature(\"transferUSDCCIP(uint256,address,uint256\", id, receiver, amount);\n    \n        messenger.sendCrossChainMessage(\n            TeleporterMessageInput({\n                destinationBlockchainID: 0x7fc93d85c6d62c5b2ac0b519c87010ea5294012d1e407030d6acd0021cac10d5,\n                destinationAddress: destinationAddress,\n                feeInfo: TeleporterFeeInfo({feeTokenAddress: address(0), amount: 0}),\n                requiredGasLimit: 250_000,\n                allowedRelayerAddresses: new address[](0),\n                message: encodedFunctionCall\n            })\n        );\n    }\n\n    function inputsToMessage(uint256 id, address receiver, uint256 amount) external pure returns (bytes memory) {\n        return \n        abi.encodeWithSignature(\"transferUSDCCIP(uint256,address,uint256)\", id, receiver, amount);\n    }\n}\n"
    },
    "lib/contracts/teleporter/ITeleporterMessenger.sol": {
      "content": "// (c) 2023, Ava Labs, Inc. All rights reserved.\n// See the file LICENSE for licensing terms.\n\n// SPDX-License-Identifier: Ecosystem\n\npragma solidity 0.8.25;\n\n// A message receipt identifies the message that was delivered by its nonce,\n// and the address that can redeem the reward for that message.\nstruct TeleporterMessageReceipt {\n    uint256 receivedMessageNonce;\n    address relayerRewardAddress;\n}\n\n// Represents all of the information required for submitting a Teleporter message\n// to be sent to the given destination chain ID and address. Includes the fee\n// information for the message, the amount of gas the relayer must provide to execute\n// the message on the destination chain, the relayer accounts allowed to deliver the\n// message, and the message data itself.\nstruct TeleporterMessageInput {\n    bytes32 destinationBlockchainID;\n    address destinationAddress;\n    TeleporterFeeInfo feeInfo;\n    uint256 requiredGasLimit;\n    address[] allowedRelayerAddresses;\n    bytes message;\n}\n\n// Represents a message sent or received by an implementation of {ITeleporterMessenger}.\nstruct TeleporterMessage {\n    uint256 messageNonce;\n    address originSenderAddress;\n    bytes32 destinationBlockchainID;\n    address destinationAddress;\n    uint256 requiredGasLimit;\n    address[] allowedRelayerAddresses;\n    TeleporterMessageReceipt[] receipts;\n    bytes message;\n}\n\n// Represents the fee information associated to a given Teleporter message.\n// The contract address is the asset contract the fee will be paid in, and\n// the amount is the amount of that specified asset.\nstruct TeleporterFeeInfo {\n    address feeTokenAddress;\n    uint256 amount;\n}\n\n/**\n * @dev Interface that describes functionalities for a cross-chain messenger implementing the Teleporter protcol.\n *\n * @custom:security-contact https://github.com/ava-labs/teleporter/blob/main/SECURITY.md\n */\ninterface ITeleporterMessenger {\n    /**\n     * @notice Emitted when the blockchain ID of the contract instance is initialized using the Warp precompile.\n     */\n    event BlockchainIDInitialized(bytes32 indexed blockchainID);\n\n    /**\n     * @notice Emitted when sending a Teleporter message cross-chain.\n     */\n    event SendCrossChainMessage(\n        bytes32 indexed messageID,\n        bytes32 indexed destinationBlockchainID,\n        TeleporterMessage message,\n        TeleporterFeeInfo feeInfo\n    );\n\n    /**\n     * @notice Emitted when an additional fee amount is added to a Teleporter message that had previously\n     * been sent, but not yet delivered to the destination chain.\n     */\n    event AddFeeAmount(bytes32 indexed messageID, TeleporterFeeInfo updatedFeeInfo);\n\n    /**\n     * @notice Emitted when a Teleporter message is being delivered on the destination chain to an address,\n     * but message execution fails. Failed messages can then be retried with `retryMessageExecution`\n     */\n    event MessageExecutionFailed(\n        bytes32 indexed messageID, bytes32 indexed sourceBlockchainID, TeleporterMessage message\n    );\n\n    /**\n     * @notice Emitted when a Teleporter message is successfully executed with the\n     * specified destination address and message call data. This can occur either when\n     * the message is initially received, or on a retry attempt.\n     *\n     * Each message received can be executed successfully at most once.\n     */\n    event MessageExecuted(bytes32 indexed messageID, bytes32 indexed sourceBlockchainID);\n\n    /**\n     * @notice Emitted when a TeleporterMessage is successfully received.\n     */\n    event ReceiveCrossChainMessage(\n        bytes32 indexed messageID,\n        bytes32 indexed sourceBlockchainID,\n        address indexed deliverer,\n        address rewardRedeemer,\n        TeleporterMessage message\n    );\n\n    /**\n     * @notice Emitted when a receipt is marked as received on the source chain that sent the\n     * corresponding Teleporter message.\n     */\n    event ReceiptReceived(\n        bytes32 indexed messageID,\n        bytes32 indexed destinationBlockchainID,\n        address indexed relayerRewardAddress,\n        TeleporterFeeInfo feeInfo\n    );\n\n    /**\n     * @notice Emitted when an account redeems accumulated relayer rewards.\n     */\n    event RelayerRewardsRedeemed(address indexed redeemer, address indexed asset, uint256 amount);\n\n    /**\n     * @notice Called by transactions to initiate the sending of a cross-chain message.\n     * @return The message ID of the newly sent message.\n     */\n    function sendCrossChainMessage(TeleporterMessageInput calldata messageInput)\n        external\n        returns (bytes32);\n\n    /**\n     * @notice Called by transactions to retry the sending of a cross-chain message.\n     *\n     * @dev Retriggers the sending of a message previously emitted by sendCrossChainMessage that has not yet been acknowledged\n     * with a receipt from the destination chain. This may be necessary in the unlikely event that less than the required\n     * threshold of stake weight successfully inserted the message in their messages DB at the time of the first submission.\n     * The message is checked to have already been previously submitted by comparing its message hash against those kept in\n     * state until a receipt is received for the message.\n     */\n    function retrySendCrossChainMessage(TeleporterMessage calldata message) external;\n\n    /**\n     * @notice Adds the additional fee amount to the amount to be paid to the relayer that delivers\n     * the given message ID to the destination chain.\n     *\n     * @dev The fee token address must be the same asset type as the fee asset specified in the original\n     * call to sendCrossChainMessage. Reverts if the message doesn't exist or there is already\n     * receipt of delivery of the message.\n     */\n    function addFeeAmount(\n        bytes32 messageID,\n        address feeTokenAddress,\n        uint256 additionalFeeAmount\n    ) external;\n\n    /**\n     * @notice Receives a cross-chain message, and marks the `relayerRewardAddress` for fee reward for a successful delivery.\n     *\n     * @dev The message specified by `messageIndex` must be provided at that index in the access list storage slots of the transaction,\n     * and is verified in the precompile predicate.\n     */\n    function receiveCrossChainMessage(uint32 messageIndex, address relayerRewardAddress) external;\n\n    /**\n     * @notice Retries the execution of a previously delivered message by verifying the payload matches\n     * the hash of the payload originally delivered, and calling the destination address again.\n     *\n     * @dev Intended to be used if message excution failed on initial delivery of the Teleporter message.\n     * For example, this may occur if the original required gas limit was not sufficient for the message\n     * execution, or if the destination address did not contain a contract, but a compatible contract\n     * was later deployed to that address. Messages are ensured to be successfully executed at most once.\n     */\n    function retryMessageExecution(\n        bytes32 sourceBlockchainID,\n        TeleporterMessage calldata message\n    ) external;\n\n    /**\n     * @notice Sends the receipts for the given `messageIDs`.\n     *\n     * @dev Sends the specified message receipts in a new message (with an empty payload) back to the source chain.\n     * This is intended for use in sending receipts that have not been sent in a timely manner by the standard\n     * receipt delivery mechanism.\n     * @return The message ID of the newly sent message.\n     */\n    function sendSpecifiedReceipts(\n        bytes32 sourceBlockchainID,\n        bytes32[] calldata messageIDs,\n        TeleporterFeeInfo calldata feeInfo,\n        address[] calldata allowedRelayerAddresses\n    ) external returns (bytes32);\n\n    /**\n     * @notice Sends any fee amount rewards for the given fee asset out to the caller.\n     */\n    function redeemRelayerRewards(address feeTokenAddress) external;\n\n    /**\n     * @notice Gets the hash of a given message stored in the EVM state, if the message exists.\n     * @return The message hash\n     */\n    function getMessageHash(bytes32 messageID) external view returns (bytes32);\n\n    /**\n     * @notice Checks whether or not the given message has been received by this chain.\n     * @return Boolean representing if the given message has been received.\n     */\n    function messageReceived(bytes32 messageID) external view returns (bool);\n\n    /**\n     * @notice Returns the address the relayer reward should be sent to on the source chain\n     * for a given message, assuming that the message has already been delivered.\n     * @return The relayer reward address for the given message.\n     */\n    function getRelayerRewardAddress(bytes32 messageID) external view returns (address);\n\n    /**\n     * @notice Gets the current reward amount of a given fee asset that is redeemable by the given relayer.\n     * @return The amount of the fee asset redeemable by the specified relayer.\n     */\n    function checkRelayerRewardAmount(\n        address relayer,\n        address feeTokenAddress\n    ) external view returns (uint256);\n\n    /**\n     * @notice Gets the fee token address and amount for a given sent message.\n     * @return The fee token address and fee amount for a the given sent message ID.\n     * If the message ID is not found, zero address and amount values are returned.\n     */\n    function getFeeInfo(bytes32 messageID) external view returns (address, uint256);\n\n    /**\n     * @notice Gets the message ID that would currently be used for the next message sent from the contract\n     * instance to the given destination blockchain.\n     *\n     * @dev This message ID may never be used in the event that the next call to sendCrossChainMessage in a\n     * transaction uses a different destination blockchain. The current value as returned by this function will\n     * change with each successful call to sendCrossChainMessage.\n     * @return The specified message ID.\n     */\n    function getNextMessageID(bytes32 destinationBlockchainID) external view returns (bytes32);\n\n    /**\n     * @notice Gets the number of receipts that are waiting to be sent to the given source chain ID.\n     * @return Size of the given queue.\n     */\n    function getReceiptQueueSize(bytes32 sourceBlockchainID) external view returns (uint256);\n\n    /**\n     * @notice Gets the receipt at the given index in the queue for the given source chain ID.\n     * @return The receipt requested.\n     */\n    function getReceiptAtIndex(\n        bytes32 sourceBlockchainID,\n        uint256 index\n    ) external view returns (TeleporterMessageReceipt memory);\n}\n"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}